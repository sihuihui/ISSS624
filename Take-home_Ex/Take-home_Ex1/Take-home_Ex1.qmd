---
title: "Take-Home Exercise 1: Geospatial Analytics for Public Good"
author: "Goh Si Hui"
date: 2023/11/26
date-format: long
date-modified: "last-modified"
format: html 
execute: 
  echo: true
  eval: true
  warning: false
editor: visual 
---

## Overview

### Introduction

As city-wide urban infrastructures such as buses, taxis, public utilities and roads become digital, data can be collected and used as a framework for tracking movement patterns through space and time. These massive movement data collected are likely to contain structure and patterns that provide useful information about characteristics of the measured phenomena. The identification, analysis and comparison of such patterns will provide greater insights on human movement and behaviours within a city. These understandings will potentially contribute to a better urban management and useful information for urban transport services providers both from the private and public sector to formulate informed decision to gain competitive advantage.

### Objectives

Exploratory Spatial Data Analysis (ESDA) hold tremendous potential to address complex problems facing society. In this take home exercise, I will be applying appropriate Local Indicators of Spatial Association (LISA) to undercover the spatial and spatio-temporal mobility patterns of public bus passengers in Singapore.

### Packages used

For this exercise, we will be using the following packages:

-   **sf**: to import and handle geospatial data,

-   **tidyverse**: to handle and wrangle attribute data,

-   **knitr**: to generate tables for matrices,

-   **sfdep**: to compute spatial weights, global and local spatial autocorrelation statistics; and

-   **tmap**: to prepare and plot cartographic quality choropleth map.

```{r}
#| code-fold: true
#| code-summary: "Show the Code"
pacman::p_load(sf, sfdep, tmap, tidyverse, knitr)
```

## Data Preparation

For the purpose of this take-home exercise, we will be using two dataset:

-   Passenger Volume by Origin Destination Bus Stops - this is an aspatial dataset in csv file format. It contains information on the number of passenger trips from origin destination bus stops.

-   Bus Stop Location - this is a geospatial dataset.It provides information from all the bus stops currently serviced by buses, including the bus stop code and location coordinates.

### Importing the Data

Firstly, we will import the `Passenger Volume by Origin Destination Bus Stops` dataset downloaded from LTA DataMall on 18 Nov 2023 using `read_csv()` of **readr** package.

```{r}
odbus_oct <- read_csv("data/aspatial/origin_destination_bus_202310.csv")
```

We will now use `st_read()` to import the geospatial data.

```{r}
busstop <- st_read(dsn = "data/geospatial", 
layer = "BusStop")
```

### Data Wrangling

We first examine the imported aspatial data using `glimpse()`.

```{r}
glimpse(odbus_oct)
```

A quick check of `odbus` tibble data frame shows that the values in `ORIGIN_PT_CODE` and `DESTINATON_PT_CODE` are in **character** data type. We will use `as.factor()` to convert `ORIGIN_PT_CODE` and `DESTINATION_PT_CODE` into **factor** data type. **Explain why it is important to convert to factor data type.**

```{r}
odbus_oct$ORIGIN_PT_CODE <- as.factor(odbus_oct$ORIGIN_PT_CODE)
odbus_oct$DESTINATION_PT_CODE <- as.factor(odbus_oct$DESTINATION_PT_CODE) 
```

Let us check the `odbus_oct` data frame again.

```{r}
glimpse(odbus_oct)
```

Let us first check the `YEAR_MONTH` to ensure it is all trips made in October 2023.

```{r}
unique(odbus_oct$YEAR_MONTH)
```

Using `unique()` function, we can find the unique values in a column. Based on the above output, we know that all the trips are made in October 2023.

Next we want to check the unique values in column `PT_TYPE`

```{r}
unique(odbus_oct$PT_TYPE)
```

Based on the above output, we know that all the trips are made by the public transport type- Bus.

```{r}
unique(odbus_oct$DAY_TYPE)
```

```{r}
unique(odbus_oct$TIME_PER_HOUR)
```

Next, we want to know more about the origin bus stops.

```{r}
length(unique(odbus_oct$ORIGIN_PT_CODE))
```

Check for any duplicate records

```{r}
duplicate <- odbus_oct %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()
```


check if there are any bus stops with no trips

```{r}
summary(odbus_oct$TOTAL_TRIPS)
```

Trips based on day type

```{r}
total_trips <- odbus_oct %>% 
  group_by(DAY_TYPE) %>%
  summarise(TOTAL = sum(TOTAL_TRIPS))
  
ggplot(total_trips) + 
  geom_col(aes(x=DAY_TYPE, y=TOTAL))
```

Trips based on Time per hour (Weekdays)

```{r}
weekday_trips <- odbus_oct %>% 
  filter(DAY_TYPE == "WEEKDAY") %>%
  group_by(TIME_PER_HOUR) %>%
  summarise(TOTAL = sum(TOTAL_TRIPS))
  
ggplot(weekday_trips) + 
  geom_col(aes(x=TIME_PER_HOUR, y=TOTAL))
```

Trips based on Time per hour (Weekends/ Holidays)

```{r}
weekend_trips <- odbus_oct %>% 
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%
  group_by(TIME_PER_HOUR) %>%
  summarise(TOTAL = sum(TOTAL_TRIPS))
  
ggplot(weekend_trips) + 
  geom_col(aes(x=TIME_PER_HOUR, y=TOTAL))
```

#### Extracting Data for this exercise

```{r}
origin_TOTAL <- odbus_oct %>% 
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TOTAL = sum(TOTAL_TRIPS)) 
```

```{r}
glimpse(origin_TOTAL)
```

```{r}
origin_WDMP <- odbus_oct %>% 
  filter(DAY_TYPE == "WEEKDAY") %>% 
  filter(TIME_PER_HOUR >= 6 &
           TIME_PER_HOUR <= 9) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(WDMP = sum(TOTAL_TRIPS))
```

```{r}
glimpse(origin_WDMP)
```

Notice that there are less origin bus stops in this dataframe

```{r}
origin_TRIPS <- left_join(origin_TOTAL, origin_WDMP)
```

```{r}
glimpse(origin_TRIPS)
```

Find out the bus stops without trips on WDMP

```{r}
origin_TRIPS %>%
  map(is.na) %>% 
  map(sum)
```


```{r}
origin_TRIPS %>% 
  filter(is.na(origin_TRIPS$WDMP)) 
```


```{r}
origin_WDAP <- odbus_oct %>% 
  filter(DAY_TYPE == "WEEKDAY") %>% 
  filter(TIME_PER_HOUR >= 17 &
           TIME_PER_HOUR <= 20) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(WDAP = sum(TOTAL_TRIPS))
```


```{r}
glimpse(origin_WDAP)
```

```{r}
origin_TRIPS <- left_join(origin_TRIPS, origin_WDAP)

```

```{r}
glimpse(origin_TRIPS)
```

```{r}
origin_TRIPS %>% 
  filter(is.na(origin_TRIPS$WDAP)) 
```


```{r}
origin_WEMP <- odbus_oct %>% 
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>% 
  filter(TIME_PER_HOUR >= 11 &
           TIME_PER_HOUR <= 14) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(WEMP = sum(TOTAL_TRIPS))
```


```{r}
glimpse(origin_WEMP)
```


```{r}
origin_TRIPS <- left_join(origin_TRIPS, origin_WEMP)

```


```{r}
glimpse(origin_TRIPS)
```


```{r}
origin_TRIPS %>% 
  filter(is.na(origin_TRIPS$WEMP)) 

```


```{r}
origin_WEEP <- odbus_oct %>% 
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>% 
  filter(TIME_PER_HOUR >= 16 &
           TIME_PER_HOUR <= 19) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(WEEP = sum(TOTAL_TRIPS))
```


```{r}
glimpse(origin_WEEP)
```



```{r}
origin_TRIPS <- left_join(origin_TRIPS, origin_WEEP)
glimpse(origin_TRIPS)
```

```{r}
origin_TRIPS %>% 
  filter(is.na(origin_TRIPS$WEEP)) 

```

Check for missing values in `origin_TRIPS` dataframe

```{r}
origin_TRIPS %>% 
  map(is.na) %>%
  map(sum)

```

Filter out rows with NA 

```{r}
origin_TRIPS[rowSums(is.na(origin_TRIPS)) > 0, ] 
```

Fill in all NA values with 0.

```{r}
origin_TRIPS <- origin_TRIPS %>% 
  replace(is.na(.), 0) 

```

Let us take a look at the geospatial data imported.

```{r}
busstop

```

From the above output, we know that the `busstop` is a simple feature data frame. It consists of 5161 features, which are point geometry type. We note that it has 3 fields and the projected CRS is SVY21.

Let us check the coordinate system further using the following code. 
```{r}
st_crs(busstop)

```

Although `busstop` data frame is projected in svy21, at the end of the print, it indicates that the EPSG is 9001. This is a wrong EPSG code because the correct EPSG code for svy21 should be 3414.Hence, we need to assign the correct ESPG code to `busstop` data frame using the `st_set_crs()` of **sf** package. 

```{r}
busstop3414 <- st_set_crs(busstop, 3414)
```
```{r}
busstop3414 
```


Let us check the CSR again

```{r}
st_crs(busstop3414)

```


Dropping columns that we do not need

```{r}
busstop3414 <- busstop3414 %>%
  select(1,3)
glimpse(busstop3414)
```

```{r}
plot(busstop3414)

```

For this exercise, we will be computing the passenger trips generated by origin at the hexagon level. Before we join the busstop location and geometry with the passenger trips data in `origin_TRIPS` dataframe, we will generate the hexagon grid first.

First, we will make a hexagon grid over the busstop datapoints.

```{r}
#make hex grid
hex_grid <- st_make_grid(busstop3414, c(500,500), crs = 3414, what = "polygons", square = FALSE)
hex_grid
```

```{r}
#make it to sf and add grid id
hex_grid_sf <- st_sf(hex_grid) %>%
  mutate(grid_id = 1:length(lengths(hex_grid)))

```

```{r}
hex_grid_sf
```

```{r}
plot(hex_grid_sf)
```

```{r}
hex_grid_sf$SG <- lengths(st_intersects(hex_grid_sf, busstop3414))
```

```{r}

sgmap <- filter(hex_grid_sf, SG>0)
sgmap
```

```{r}
plot(sgmap)
```

```{r}
busstop_sgmap <- st_intersection(busstop3414, sgmap) 
busstop_sgmap 
```

```{r}
busstop_grid_id <- st_intersection(busstop3414, sgmap) %>%
  st_drop_geometry()
busstop_grid_id
```

```{r}
write_rds(busstop_grid_id, "data/rds/busstop_grid_id.rds")  
```

```{r}
busstop_trips <- left_join(busstop_grid_id,origin_TRIPS,
                           by = c("BUS_STOP_N" = "ORIGIN_PT_CODE")) %>%
  rename(ORIGIN_BS = BUS_STOP_N) 

busstop_trips
```

check for missing values

```{r}
busstop_trips %>% 
  map(is.na) %>%
  map(sum)
```

filter out rows with these missing values
```{r}
busstop_trips[rowSums(is.na(busstop_trips)) > 0, ] 
```


check what are these busstops that do not have values 


check for duplicates 

```{r}
duplicate1 <- busstop_trips %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()

```

```{r}
duplicate1
```

```{r}
busstop_trips <- unique(busstop_trips)
```

```{r}
duplicate2 <- busstop_trips %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()

```


count number of bus stops in busstop_trips

```{r}
busstop_trips1 <- busstop_trips %>% 
  group_by(grid_id)%>%
  summarise(TOTALBS_PER_GRID = n(), 
            TOTALTRIPS_PER_GRID = sum(TOTAL),
            TOTALWDMP_PER_GRID = sum(WDMP),
            TOTALWDAP_PER_GRID = sum(WDAP), 
            TOTALWEMP_PER_GRID = sum(WEMP),
            TOTALWEEP_PER_GRID = sum(WEEP))


```

```{r}
origintrip_hex <- left_join(sgmap,busstop_trips1,
                            by = "grid_id")
head(origintrip_hex)
```

```{r}
glimpse(origintrip_hex)
```

Plot some charts here to check if several busstops were in the grid.

```{r}
ggplot(origintrip_hex, aes(x=TOTALBS_PER_GRID)) + 
  geom_histogram()
```

## GeoVisualisation

```{r}
tmap_mode("plot")
tm_shape(origintrip_hex)+
  tm_fill("TOTALBS_PER_GRID", 
          style = "quantile", 
          palette = "Blues",
          title = "Total Bus Stops") +
  tm_layout(main.title = "Total Passenger Trips from Origin Bus Stops in October 2023",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Passenger trips data from LTA", 
             position = c("left", "bottom"))

```

```{r}
tmap_mode("plot")
tm_shape(origintrip_hex)+
  tm_fill("TOTALWDMP_PER_GRID", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger Trips") +
  tm_layout(main.title = "Passenger Trips during Weekday AM Peak in Oct 2023",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Passenger trips data from LTA", 
             position = c("left", "bottom"))

```

```{r}
tmap_mode("plot")
tm_shape(origintrip_hex)+
  tm_fill("TOTALWDAP_PER_GRID", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger Trips") +
  tm_layout(main.title = "Passenger trips during Weekday PM Peak in Oct 2023",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Passenger trips data from LTA", 
             position = c("left", "bottom"))

```

```{r}
tm_shape(origintrip_hex)+
  tm_fill("TOTALWEMP_PER_GRID", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger Trips") +
  tm_layout(main.title = "Passenger trips during Weekend AM Peak in Oct 2023",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Passenger trips data from LTA", 
             position = c("left", "bottom"))

```

```{r}
tm_shape(origintrip_hex)+
  tm_fill("TOTALWEEP_PER_GRID", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger Trips") +
  tm_layout(main.title = "Passenger trips during Weekend PM Peak in Oct 2023",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Passenger trips data from LTA", 
             position = c("left", "bottom"))

```

## Local Indicators of Spatial Association (LISA) Analysis

Local Indicators of Spatial Association or LISA are statistics that evaluate the existence of clusters in the spatial arrangement of a given variable. 

```{r}
head(origintrip_hex)
```

Deriving neighbours based on Fixed Distance
```{r}
geo <- sf::st_geometry(origintrip_hex)
nb <- st_knn(geo, longlat = TRUE)
dists <- unlist(st_nb_dists(geo, nb))

```

```{r}
summary(dists)
```

```{r}
wm_fd <- origintrip_hex %>%
  mutate(nb = st_dist_band(hex_grid,
                           upper = 4273),
               wt = st_weights(nb),
               .before = 1)
```
```{r}
glimpse(wm_fd)
```

Adaptive distance weights

```{r}
wm_ad <- origintrip_hex %>% 
  mutate(nb = st_knn(hex_grid,
                     k=8),
         wt = st_weights(nb),
               .before = 1)

```

```{r}
glimpse(wm_ad)
```

Inverse Distance Weights 

```{r}
wm_idw <- origintrip_hex %>%
  mutate(nb = st_contiguity(hex_grid),
         wt = st_inverse_distance(nb, hex_grid,
                                   scale = 1,
                                   alpha = 1),
         .before = 1)

```

```{r}
glimpse(wm_idw) 
```

Computing Local Moran's I 

```{r}
wm_fd %>%
  map(is.na) %>% 
  map(sum)
```

fill in with 0 

```{r}
wm_fd <- wm_fd %>% 
  replace(is.na(.), 0) 

```


```{r}
wm_fd %>%
  map(is.na) %>% 
  map(sum)
```


```{r}
lisa_fd_WDMP <- wm_fd %>% 
  mutate(local_moran = local_moran(TOTALWDMP_PER_GRID, zero.policy=FALSE,
                                   nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)

```


```{r}
tmap_mode("plot")
tm_shape(lisa_fd_WDMP) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of WDMP",
            main.title.size = 0.8)

```


```{r}
tmap_mode("plot")
tm_shape(lisa_fd_WDMP) +
  tm_fill("p_ii_sim") + 
  tm_borders(alpha = 0.5) +
   tm_layout(main.title = "p-value of local Moran's I",
            main.title.size = 0.8)

```


```{r}
tmap_mode("plot")
map1 <- tm_shape(lisa_fd_WDMP) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of GDPPC",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_fd_WDMP) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)

```


```{r}
lisa_sig_WDMP <- lisa_fd_WDMP  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa_fd_WDMP) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_WDMP) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```


```{r}
lisa_fd_WDAP <- wm_fd %>% 
  mutate(local_moran = local_moran(TOTALWDAP_PER_GRID, zero.policy=FALSE,
                                   nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)

```

```{r}

tmap_mode("plot")
map1 <- tm_shape(lisa_fd_WDAP) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Local Moran's I for Weekday Afternoon Peak Passenger Trips",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_fd_WDAP) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I for Weekday Afternoon Peak Passenger Trips",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)


```

```{r}
lisa_sig_WDAP <- lisa_fd_WDAP  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa_fd_WDAP) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_WDAP) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```

```{r}
lisa_fd_WEMP <- wm_fd %>% 
  mutate(local_moran = local_moran(TOTALWEMP_PER_GRID, zero.policy=FALSE,
                                   nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)

```

```{r}

tmap_mode("plot")
map1 <- tm_shape(lisa_fd_WEMP) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Local Moran's I for Weekend Morning Peak Passenger Trips",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_fd_WEMP) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I for Weekend Morning Peak Passenger Trips",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)


```

```{r}
lisa_sig_WEMP <- lisa_fd_WEMP  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa_fd_WEMP) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_WEMP) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```

```{r}
lisa_fd_WEEP <- wm_fd %>% 
  mutate(local_moran = local_moran(TOTALWEEP_PER_GRID, zero.policy=FALSE,
                                   nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)

```

```{r}

tmap_mode("plot")
map1 <- tm_shape(lisa_fd_WEEP) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "Local Moran's I for Weekend Evening Peak Passenger Trips",
            main.title.size = 0.8)

map2 <- tm_shape(lisa_fd_WEEP) +
  tm_fill("p_ii_sim",
          breaks = c(0, 0.001, 0.01, 0.05, 1),
              labels = c("0.001", "0.01", "0.05", "Not sig")) + 
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "p-value of local Moran's I for Weekend Evening Peak Passenger Trips",
            main.title.size = 0.8)

tmap_arrange(map1, map2, ncol = 2)


```

```{r}
lisa_sig_WEEP <- lisa_fd_WEEP  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa_fd_WEEP) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig_WEEP) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```
